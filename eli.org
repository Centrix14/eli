#+title: ELI - Early (and Experimental) LN Interpreter
#+author: Centrix14
#+startup: overview

* ELI development
** Stages
*** DONE Parser [7/7]
- [X] Create =parser= class
- [X] Create pars words
- [X] Create pars sequences
- [X] Add print-object to all classes
- [X] Add streams
- [X] Add pars-stream method
- [X] Refactor parser, remove OOP

*** TODO Rule processing system [0/3]
- [ ] Create =rule= class
- [ ] Create =rule-storage= class
- [ ] Add tasks

* System definitions
** =eli= system definition
#+name: eli system definition
#+begin_src lisp :tangle eli.asd
  (defsystem "eli"
    :description "ELI — Early (and Experimental) LN Interpreter"
    :version "0.0"
    :author "Centrix14"
    :maintainer "Centrix14"
    :homepage "https://github.com/Centrix14/eli"
    :licence "GNU GPL v3"
    :depends-on (:asdf)
    :components ((:file "src/parser/parser")
                 (:file "src/parser/auxiliary")))
#+end_src

** =eli= system loader
#+name: eli system loader
#+begin_src lisp :tangle eli.lisp
  (require :asdf)

  (asdf:load-asd (merge-pathnames "eli.asd" (uiop:getcwd)))
  (asdf:load-system :eli)
#+end_src

** =eli= tests definition
#+name: eli tests definition
#+begin_src lisp :tangle eli-tests.asd
  (defsystem "eli-tests"
    :description "ELI tests"
    :licence "GNU GPL v3"
    :depends-on (:asdf :eli)
    :components ((:file "t/parser/read-next-word")))
#+end_src

** =eli= tests loader
#+name: eli tests loader
#+begin_src lisp :tangle eli-tests.lisp
  (require :asdf)

  (asdf:load-asd (merge-pathnames "eli.asd" (uiop:getcwd)))
  (asdf:load-asd (merge-pathnames "eli-tests.asd" (uiop:getcwd)))

  (asdf:load-system :eli)
  (asdf:load-system :eli-tests)
#+end_src

** =eli= examples definition
#+begin_src lisp :tangle eli-examples.asd
  (defsystem "eli-examples"
    :description "Examples for ELI"
    :licence "GNU GPL v3"
    :depends-on (:asdf :eli)
    :components ((:file "examples/read-next-word")))
#+end_src

** =eli= examples loader
#+begin_src lisp :tangle eli-examples.lisp
  (require :asdf)

  (asdf:load-asd (merge-pathnames "eli.asd" (uiop:getcwd)))
  (asdf:load-asd (merge-pathnames "eli-examples.asd" (uiop:getcwd)))

  (asdf:load-system :eli)
  (asdf:load-system :eli-examples)
#+end_src

* Parser
** =read-next-word= function
=read-next-word= reads next word from /stream/. Words separated by
separators — a string, or vector of characters.

If end of stream has been reached, function returns =nil=.

#+begin_src lisp :tangle src/parser/parser.lisp
  (defun read-next-word (stream &optional (separators " "))
    (if (end-of-stream-p stream)
        nil
        (%read-next-word% stream separators)))
#+end_src

As you can see, =read-next-word= use internal function, that makes all
magic of parsing. Please, don't use it in your code, be a good boys.

Here you can see a =buffer= — vector, that store readed word, =c= — a
variable, storing readed char.

The logic of function is following:
1. Until end of stream has been reached, or separator has been reached
   and word was readed (this need to avoid returning void words) do:
2. Store character to buffer, if it's not a separator.
3. Read another char, save it to =c=.
4. In the end, when word has been readed, return it.

#+begin_src lisp :tangle src/parser/parser.lisp
  (defun %read-next-word% (stream separators)
    (let ((buffer (make-array 0
                              :fill-pointer 0
                              :adjustable t
                              :element-type 'character))
          (c
            (read-char stream nil 'the-end)))

      (loop until (or
                   (eql c 'the-end)
                   (and (separatorp separators c)
                        (> (length buffer) 0)))
            do
               (unless (separatorp separators c)
                   (vector-push-extend c buffer))

               (setf c (read-char stream nil 'the-end)))

      buffer))
#+end_src

*** Example
And here you can see an example of usage of this function.

<<read-next-word usage example>>:

#+begin_src lisp :tangle examples/read-next-word.lisp
  (let ((str "word1 word2")
        (seps (vector #\Space
                       #\Newline
                       #\Tab)))
    (with-input-from-string (stream str)
      (loop with word = (read-next-word stream seps)
            until (null word) do
              (format t "~a~%" word)
              (setf word (read-next-word stream seps)))))
#+end_src

In this example we create a string =str=, with ="word1 word2"= contents,
create a vector of separators, named =seps=, and then read words from
=str= with the help of =with-input-from-string= (remember: =read-next-word=
work with streams, not with files or strings). Reading is a loop, that
will end when =read-next-word= will return =nil= — a special value, that
indicates ending of stream.

** Predicates
*** =separatorp=
#+begin_src lisp :tangle src/parser/parser.lisp
  (defun separatorp (separators char)
    (if (position char separators)
        t
        nil))
#+end_src

*** =end-of-stream-p=
#+begin_src lisp :tangle src/parser/parser.lisp
  (defun end-of-stream-p (stream)
    (let ((c
            (read-char stream nil 'the-end))
          (result nil))
    
      (if (eql c 'the-end)
          (setf result t))
    
      (unread-char c stream)
      result))
#+end_src

* Tests
** parser tests
*** =read-next-word= test
#+begin_src lisp :tangle t/parser/read-next-word.lisp
  (let ((str
          "atom while

  rule [ while .seq:cond .seq:body ]
       [ rule [ while 1 .seq ]
              [ while cond body ] ]")
        (seps (vector #\Space
                      #\Newline
                      #\Tab)))
    (with-input-from-string (stream str)
      (loop with word = (read-next-word stream seps)
            until (null word)
            do
               (format t "~a~%" word)
               (setf word (read-next-word stream seps)))))
#+end_src
