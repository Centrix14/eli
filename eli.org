#+title: ELI - Early (and Experimental) LN Interpreter
#+author: Centrix14
#+startup: overview

* ELI development
** Stages
*** TODO Parser [7/8]
- [X] Create =parser= class
- [X] Create pars words
- [X] Create pars sequences
- [X] Add print-object to all classes
- [X] Add streams
- [X] Add pars-stream method
- [X] Refactor parser, remove OOP
- [ ] Add strings parsing

*** TODO Rule processing system [0/3]
- [ ] Create =rule= class
- [ ] Create =rule-storage= class
- [ ] Add tasks

* System definitions
** =eli= system definition
#+name: eli system definition
#+begin_src lisp :tangle eli.asd
  (defsystem "eli"
    :description "ELI — Early (and Experimental) LN Interpreter"
    :version "0.0"
    :author "Centrix14"
    :maintainer "Centrix14"
    :homepage "https://github.com/Centrix14/eli"
    :licence "GNU GPL v3"
    :depends-on (:asdf)
    :components ((:file "src/parser/parser")
                 (:file "src/interpreter/main")
                 (:file "src/interpreter/auxiliary")))
#+end_src

** =eli= system loader
#+name: eli system loader
#+begin_src lisp :tangle eli.lisp
  (require :asdf)

  (asdf:load-asd (merge-pathnames "eli.asd" (uiop:getcwd)))
  (asdf:load-system :eli)
#+end_src

** =eli= tests definition
#+name: eli tests definition
#+begin_src lisp :tangle eli-tests.asd
  (defsystem "eli-tests"
    :description "ELI tests"
    :licence "GNU GPL v3"
    :depends-on (:asdf :eli)
    :components ((:file "t/parser/read-next-word")
                 (:file "t/interpreter/ln-eval-stream")))
#+end_src

** =eli= tests loader
#+name: eli tests loader
#+begin_src lisp :tangle eli-tests.lisp
  (require :asdf)

  (asdf:load-asd (merge-pathnames "eli.asd" (uiop:getcwd)))
  (asdf:load-asd (merge-pathnames "eli-tests.asd" (uiop:getcwd)))

  (asdf:load-system :eli)
  (asdf:load-system :eli-tests)
#+end_src

** =eli= examples definition
#+begin_src lisp :tangle eli-examples.asd
  (defsystem "eli-examples"
    :description "Examples for ELI"
    :licence "GNU GPL v3"
    :depends-on (:asdf :eli)
    :components ((:file "examples/read-next-word")))
#+end_src

** =eli= examples loader
#+begin_src lisp :tangle eli-examples.lisp
  (require :asdf)

  (asdf:load-asd (merge-pathnames "eli.asd" (uiop:getcwd)))
  (asdf:load-asd (merge-pathnames "eli-examples.asd" (uiop:getcwd)))

  (asdf:load-system :eli)
  (asdf:load-system :eli-examples)
#+end_src

* Parser
** =read-next-word= function
=read-next-word= reads next word from /stream/. Words separated by
separators — a string, or vector of characters.

If end of stream has been reached, function returns =nil=.

#+begin_src lisp :tangle src/parser/parser.lisp
  (defun read-next-word (stream &optional (separators " "))
    (if (end-of-stream-p stream)
        nil
        (%read-next-word% stream separators)))
#+end_src

As you can see, =read-next-word= use internal function, that makes all
magic of parsing. Please, don't use it in your code, be a good boys.

Here you can see a =buffer= — vector, that store readed word, =c= — a
variable, storing readed char.

The logic of function is following:
1. Until end of stream has been reached, or separator has been reached
   and word was readed (this need to avoid returning void words) do:
2. Store character to buffer, if it's not a separator.
3. Read another char, save it to =c=.
4. In the end, when word has been readed, return it.

#+begin_src lisp :tangle src/parser/parser.lisp
  (defun %read-next-word% (stream separators)
    (let ((buffer (make-array 0
                              :fill-pointer 0
                              :adjustable t
                              :element-type 'character))
          (c
            (read-char stream nil 'the-end)))

      (loop until (or
                   (eql c 'the-end)
                   (and (separatorp separators c)
                        (> (length buffer) 0)))
            do
               (unless (separatorp separators c)
                   (vector-push-extend c buffer))

               (setf c (read-char stream nil 'the-end)))

      buffer))
#+end_src

*** Example
And here you can see an example of usage of this function.

<<read-next-word usage example>>:

#+begin_src lisp :tangle examples/read-next-word.lisp
  (let ((str "word1 word2")
        (seps (vector #\Space
                       #\Newline
                       #\Tab)))
    (with-input-from-string (stream str)
      (loop with word = (read-next-word stream seps)
            until (null word) do
              (format t "~a~%" word)
              (setf word (read-next-word stream seps)))))
#+end_src

In this example we create a string =str=, with ="word1 word2"= contents,
create a vector of separators, named =seps=, and then read words from
=str= with the help of =with-input-from-string= (remember: =read-next-word=
work with streams, not with files or strings). Reading is a loop, that
will end when =read-next-word= will return =nil= — a special value, that
indicates ending of stream.

** Predicates
*** =separatorp=
#+begin_src lisp :tangle src/parser/parser.lisp
  (defun separatorp (separators char)
    (if (position char separators)
        t
        nil))
#+end_src

*** =end-of-stream-p=
#+begin_src lisp :tangle src/parser/parser.lisp
  (defun end-of-stream-p (stream)
    (let ((c
            (read-char stream nil 'the-end))
          (result nil))

      (if (eql c 'the-end)
          (return-from end-of-stream-p t))

      (unread-char c stream)
      nil))
#+end_src

* Interpreter
** =ln-eval-stream= function
This function interprets code that coming from some stream.

It use these internal variables:
- =expression= — a readed expression
- =word= — a readed word
- =separators= — actually, this is just a constant, that make code more
  simple (i can just write "separators" instead of whole vector).

And while there is some words in stream, it reads they, and store in
=exprssion=.

Also, there is some interest logic: an =updated= and =word= nesting. What
is it? =word-nesting= is a nesting degree of current word, word that
will be stored to expression. And =updated-nesting= is a nesting degree
of all next words.

#+begin_src lisp :tangle src/interpreter/main.lisp
  (defun ln-eval-stream (stream)
    (let ((expression (make-array 0
                                  :fill-pointer 0
                                  :adjustable t
                                  :element-type 'list))
          (word "")
          (nesting-degree 0)
          (separators (vector #\Space
                              #\Newline
                              #\Tab)))

      (setf word (read-next-word stream separators))
      (loop until (null word) do
        (multiple-value-bind (updated-nesting word-nesting)
            (get-nesting word nesting-degree)

          (vector-push-extend (make-it-element word word-nesting)
                              expression)
          (setf nesting-degree updated-nesting))

        (setf word (read-next-word stream separators)))

      (print-it expression)))
#+end_src

As you can see, in the end of work function calls =print-it=. This is
just a test, don't on this seriously.

<<ln-eval-stream usage example>>:

#+begin_src lisp :tangle examples/interpreter/ln-eval-stream.lisp
  (with-open-file (stream "../ln/if.ln"
                          :direction :input
                          :if-does-not-exist :error)
    (ln-eval-stream stream))
#+end_src

In this example we open file for reading, and then, give it to
=ln-eval-string=, nothing unusual, as you see.

** Auxiliary functions
*** =get-nesting= function
This function returns 2 parameters:
- =updated-nesting= — nesting degree of all next words
- =current-nesting= (or =word-nesting=) — nesting degree of current word

#+begin_src lisp :tangle src/interpreter/auxiliary.lisp
  (defun get-nesting (word current-nesting)
    (cond
      ((string= word "[")
       (values (1+ current-nesting) current-nesting))

      ((string= word "]")
       (values (1- current-nesting) (1- current-nesting)))

      (t
       (values current-nesting current-nesting))))
#+end_src

<<get-nesting usage example>>:

#+begin_src lisp :tangle examples/interpreter/get-nesting.lisp
  (multiple-value-bind (updated-nesting current-nesting) (get-nesting "[" 0)
    (format t "~a ~a~%" updated-nesting current-nesting))
#+end_src

Since =get-nesting= is a trivial function, usage example it simple and
clear. We just bind values returned by function to =updated-nesting= and
=current-nesting= variables, and then use it.

*** =print-it= function
=print-it= is a function, that prints index-tree on the screen. In
printing it uses tabs, to show nesting. Nothing interest, you know.

#+begin_src lisp :tangle src/interpreter/auxiliary.lisp
  (defun print-it (tree)
    (loop for element across tree do
      (format t "~a~a~%"
              (print-it-get-nesting-string (first element))
              (second element))))
#+end_src

<<print-it usage example>>:

#+begin_src lisp :tangle examples/interpreter/print-it.lisp
  (print-it #((0 "zero") (1 "one") (2 "two") (3 "three")))
#+end_src

In this example we print simple test tree on the screen.

**** =print-it-get-nesting-string= inner function
#+begin_src lisp :tangle src/interpreter/auxiliary.lisp
  (defun print-it-get-nesting-string (nesting-degree)
    (loop with result = (make-array 0
                                    :fill-pointer 0
                                    :adjustable t
                                    :element-type 'character)
          repeat nesting-degree do
            (vector-push-extend #\Tab result)
          finally (return-from print-it-get-nesting-string result)))
#+end_src

*** =make-it-element= function
This function is pretty simple and small: it just create new element
of index-tree. That's all folks!

#+begin_src lisp :tangle src/interpreter/auxiliary.lisp
  (defun make-it-element (word nesting-degree)
    (list nesting-degree word))
#+end_src

<<make-it-element usage example>>:

#+begin_src lisp :tangle examples/interpreter/make-it-element.lisp
  (format t "~a~%" (make-it-element "my-word" 0))
#+end_src

In this example we create new it element containing word ="my-word"= and
nesting-degree =0=.

* Tests
** parser tests
*** =read-next-word= test
#+begin_src lisp :tangle t/parser/read-next-word.lisp
  (let ((str
          "atom while

  rule [ while .seq:cond .seq:body ]
       [ rule [ while 1 .seq ]
              [ while cond body ] ]")
        (seps (vector #\Space
                      #\Newline
                      #\Tab)))

    (with-input-from-string (stream str)
      (format t "read-next-word test~%")
      (loop with word = (read-next-word stream seps)
            until (null word)
            do
               (format t "~a~%" word)
               (setf word (read-next-word stream seps)))))
#+end_src

** interpreter tests
*** =ln-eval-stream= test
#+begin_src lisp :tangle t/interpreter/ln-eval-stream.lisp
  (with-open-file (stream "examples/ln/if.ln"
                          :direction :input
                          :if-does-not-exist :error)
    (format t "~%~%ln-eval-stream test~%")
    (ln-eval-stream stream))
#+end_src
